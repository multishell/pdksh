General features of at&t ksh that are not (yet) in pdksh:
  (Note that this list is probably not complete and some of these features
  are not in all at&t ksh's)
    - coprocesses (ie, command |&) and related paraphernalia (read -p,
      print -p, >&p)
    - exported aliases
    - exported functions
    - set -tr, set -o bgnice/gmacs/markdirs/nolog/restricted.
    - signals/traps not cleared during functions
    - trap DEBUG
    - ERRNO, LINENO, LINES parameters
    - cd/pwd doesn't have -L or -P options (not all at&t ksh's have this)
    - extended file globbing/pattern matching (ei, [?*+@!](pattern list)).
      Also, doesn't have posix file globbing (eg, [[:alpha:]], etc.)
    - use of an `agent' to execute unreadable/setuid/setgid shell scripts

Known differences between pdksh & at&t ksh (that are not likely to change)
    - vi:
	- `G': at&t: goes to oldest command, pdksh: newest command
	- `^U': at&t: kills only what has been inserted, pdksh: kills to
	  start of line
    - ignore SIGTSTP,SIGTTIN,SIGTTOU in exec'd processes when talking
      and not monitoring (at&t ksh kind of does this).  Doesn't really make
      sense.
      (Note that ksh.att -ic 'set +m; check-sigs' shows TSTP et al aren't
       ignored, while ksh.att -ic 'set +m^J check-sigs' does... very strange)
    - at&t ksh seems to catch or ignore SIGALRM - pdksh dies upon receipt
    - wait should be interruptible by any signal (eg, ALARM)?
      Question: if a signal is received during the execution of a built-in,
      does the builtin command exit or the whole shell?
    - typeset:
	- at&t ksh overloads -u/-l options: for integers, means unsigned/long,
	  for strings means uppercase/lowercase; pdksh just has the
	  upper/lower case (which can be useful for integers when base > 10).
	  unsigned/long really should have their own options.
	- at&t ksh can't have justified integer variables
	  (eg, typeset -iR5 j=10), pdksh can.
	- in pdksh, number arguments for -L/-R/-Z/-i must follow the option
	  character, at&t allows it at the end of the option group (eg,
	  at&t ksh likes "typeset -iu5 j", pdksh wants "typeset -i5 -u j"
	  or "typeset -ui5 j").  Also, pdksh allows "typeset -i 5 j" (same
	  as "typeset -i5 j"), at&t ksh does not allow this.
	- typeset -R: pdksh strips trailing space type characters (ie,
	  uses isspace()), at&t ksh only skips blanks.
	- at&t ksh allows attributes of read-only variables to be changed,
	  pdksh allows only the export attribute to be changed.
    - at&t ksh allows set -A of readonly variables, pdksh does not.
    - at&t ksh seems to allow function calls inside expressions
      (eg, typeset -i x='y(2)') but they do not seem to be regular functions
      nor math functions (eg, pow, exp).
    - `set -o nounset; unset foo; echo ${#foo}`: at&t ksh prints 0; pdksh
      generates error.  Same for ${#foo[*]} and ${#foo[@]}.
    - at&t ksh likes `typeset -i x=2; let x=` (results in x being 0). pdksh
      generates expression error. same for `typeset -i x=2; x=`.
    - . file: at&t ksh parses the whole file before executing anything,
      pdksh executes as it parses.  This means aliases defined in the file
      will affect how pdksh parses the file, but won't affect how at&t ksh
      parses the file.
    - at&t ksh does file globbing for `echo "${foo:-"*"}"`, pdksh does not
      (POSIX would seem to indicate pdksh is right).
    - at&t ksh thinks ${a:##foo} is ok, pdksh doesn't.
    - at&t does tilde expansion on here-document delimiters, pdksh does
      not.  eg.
	$ cat << ~michael
	~michael
	$ 
      works for pdksh, not for at&t ksh (POSIX seems to agree with pdksh).
    - TMOUT: at&t prints warning, then waits another 60 seconds.  If on screwed
      up serial line, the output could cause more input, so pdksh just
      prints a message and exits.  (Also, in at&t ksh, setting TMOUT has no
      effect after the sequence "TMOUT=60; unset TMOUT", which could be
      useful - pdksh may do this in the future).
    - in at&t ksh, tracked aliases have the export flag implicitly set
      and tracked aliases and normal aliases live in the same name space
      (eg, "alias" will list both tracked and normal aliases).
      in pdksh, -t does not imply -x (since -x is not supported yet), and
      tracked/normal aliases live in seperate name spaces.
      in at&t ksh, alias accepts + options (eg, +x, +t) - pdksh does not.
      in pdksh, alias has a -d option to allow examination/changing of
      cached ~ entries, also unalias has -d and -t options (unalias -d
      is useful if the ~ cache gets out of date - not sure how at&t deals
      with this problem (it does cache ~ entries)).
      "alias -t vi; PATH=$PATH; whence -p vi; alias -t | grep vi"
      will re-track vi in at&t ksh, not in pdksh.
    - at&t ksh will stop a recursive function after about 60 calls; pdksh
      will not since the limit is arbitrary and can't be controlled
      by the user (hit ^C if you get in trouble).
    - a return in $ENV in at&t ksh will cause the shell to exit, while in
      pdksh it will stop executing the script (this is consistent with
      what a return in .profile does in both shells).
    - the wait command (with and without arguments) in at&t ksh will wait for
      stopped jobs when job control is enabled.  pdksh doesn't.

Oddities in ksh (pd & at&t):
    - array references inside (())/$(()) are strange:
	  $(( x[2] )) does the expected, $(( $x[2] )) doesn't.
    - `typeset -R3 X='x '; echo "($X)"` produces (  x) - trailing
      spaces are stripped.
    - typeset -R turns off Z flag.
    - both shells have the following mis-feature:
	$ x='function xx {
		cat -n <<- EOF
		here we are in xx
		EOF
		}'
	$ (eval "$x"; (sleep 2; xx) & echo bye)
	[1] 1234
	bye
	$ xx: /tmp/sh1234.1: cannot open
    - bizarre special handling of alias/export/readonly/typeset arguments
	$ touch a=a; typeset a=[ab]; echo "$a"
	a=[ab]
	$ x=typeset; $x a=[ab]; echo "$a"
	a=a
	$ 

Questions from 4.9 merge:
    - table.h, tree.h (and other spots)
	- short and char fields changed to int, why?
    - histbackup() doesn't seem to be doing its job: `fc -e -' shows
      up in history (at&t ksh replaces the fc line with the edit result)
    - why is there an mcheck() and an mprint()?  why not have mcheck() print
      the messages directly?  This would obviate the need to allocate/free
      messages.

Known bugs:
    Variable parsing, Expansion:
	- `echo ${:}' should not ask for more input
	- `echo ${^}' should print bad subst error
	- some specials behave differently when unset (eg, IFS behaves like
	  " \t\n") others loose their special meaning.  IFS taken care of,
	  still need to sort out others.
    Parsing,Lexing:
	- the following
	    $ alias X='case '
	    $ alias Y=Z
	    $ X Y in 'Y') echo is y ;; Z) echo is z ; esac
	  should print is y, not is z.
    Commands,Execution:
	- in interactive shells, `exec print hi' prints hi and continues to
	  read commands.  Problem is with the unwind function.
	- `echo hi | exec cat -n' causes at&t to exit, `exec echo hi | cat -n'
	  does not.  pdksh exits for neither.
    Misc:
	- file name globbing: globbing should only be done if the pattern is
	  syntactically correct, eg, `echo [ab--]*' should produce "[ab--]*",
	  not all the files starting with a or b.
	- read (c_read) is not interruptible by ^C (see comments on traps in
	  the PROJECTS file).
	- set -$- will not do the expected thing for -s and -i. Haven't checked
	  if this is a problem for POSIX (at&t ksh has similar problems).

at&t ksh bugs:
    [various versions:
	MIPS m120 RISC/os 5.0: Version 11/16/88d
	Dec alpha osf/1 v1.3:  OSF/1 Version 11/16/88d NLS
	HP pa HP-UX 9.01:  Version 11/16/88
     ]
    - (only hpux)
      $ _[2]=hi
      Bus error (core dumped)
    - (only riscos, hpux)
      $ typeset x[
      $ 
    - (only osf/1)
      $ A=B cat << EOF
      .$A.
      EOF
      Segmentation fault(coredump)
      $ 
    - (only osf/1)
      $ read "?foo "
      foo Foo
      $ set | grep Foo
      =Foo
      $ 
    - (all)
      $ typeset -i A
      $ typeset -L3 A
      $ typeset -l A
      Illegal instruction (core dumped)
    - (all)
      $ for i in a b c ; do echo $i, ${i[2]}, ${i[10]} ; done
      a, ,
      a, , b
      a, , c
      $ 
    - (all)
      $ echo ${abc:-G { I } K }
      G { I K }
      $ 
      $ abc=hi
      $ echo ${abc:-G { I } K }
      hi K }
      $
      The second echo should only have printed `hi'.
    - (all)
      $ echo ${abc:- > foo}
      syntax error: > unexpected
      $ 
    - (all? hpux) read reads too much from pipe (when pipe isn't stdin)
	print 'hi\nthere' | ksh 8<&0 0< /dev/tty
	    $ read -u8 x
	    $ print $x
	    hi
	    $ cat 0<&8
	    $ read -u8 y
	    $ print $y
	    there
	    $ 
    - (all)
	$ umask 0
	$ umask
	00
	$
    - (osf, mips, !hpux)
	$ exec alias
	alias: not found
	(shell dead)
    - (all) non-white space IFS in non-substitution not preserved
	$ IFS="$IFS:"
	$ echo : "$@"		# this is ok
	:
	$ echo :"$@"		# this should print : too (me thinks)
 
	$ 
    - (only osf/1)
	$ set +m
	$ sleep 1 &		# wait for a sec or two
	$ jobs
	Memory fault (core dumped)
    - (all)
	$ (sleep 1 & echo hi) &
	[1] 123
	$ [1] 234
	hi
    - (osf/1, mips)
	$ getopts abc optc -a -b -c
	$ getopts abc optc -a -b -c
	$ getopts abc optc -a
	Memory fault (core dumped)
    - (osf/1) POSIX says OPTIND shall be initialized to 1
	$ echo $OPTIND
	0
	$ 
    - (osf/1 + others?)
	$ typeset -ri r=10
	$ let r=12
	$ echo $r
	12
	$ 
    - (osf/1 + others?)
	$ typeset -i a
	$ typeset -L3 a
	Memory fault (core dumped)
    - (osf/1 + others?): -L strips leading \ \t\n\r, -R only strips trailing
      spaces
	$ typeset -L3 x
	$ x=' ^I^J^M 2'
	$ echo "($x)"
	(2  )
	$ typeset -R3 y
	$ x='2^I^J^M '
	$ echo "($x)"
	(^I^J^M)
	$ 
    - (osf/1 + others?)
	$ typeset +i RANDOM
	Memory fault (core dumped)
    - (osf/1 + others?): -L/-R/-Z clear -l/-u after assignment and vise versa
	$ typeset -u x=ab
	$ echo "($x)"
	(AB)
	$ typeset -L4 x=def
	$ echo "($x)"
	(DEF )
	$ typeset | grep ' x$'
	leftjust 4 x
	$ 
	$ typeset -L4 x=def
	$ echo "($x)"
	(def )
	$ typeset -u x=ab
	$ echo "($x)"
	(AB  )
	$ typeset | grep ' x$'
	uppercase x
	$ 
	$ typeset -i x
	$ x='2()'
	$ x='()'
	$ x='2(4)'
    - (osf/1, others?)
	$ unset foo
	$ echo "${foo:-"*"}"
	<results of * expansion>
	$ 
    - (osf/1, others?)
	$ alias blah
	blah: alias not found
	$ alias -x blah | grep blah
	blah
	$ type blah
	Memory fault (core dumped)
    - (osf/1, others?)
	$ trap 'echo hi; false' ERR
	$ false
	hi
	hi
	....
	Memory fault (core dumped)
    - (osf/1, others?)
	$ typeset +i ERRNO
	Memory fault (core dumped)

POSIX sh bugs (references are to POSIX 1003.2-1992)
	- in vi insert mode, ^W deletes to beginning of line or to the first
	  blank/punct character (para at line 9124, section 3).  This means
	  "foo     ^W" will do nothing.  This is inconsistent with the vi
	  spec, which says delete preceding word including and interceding
	  blanks (para at line 5189, section 5).
	- parameter expansion, section 3.6.2, line 391: `in each case that a
	  value of word is needed (..), word shall be subjected to tilde
	  expansion, parameter expansion, ...'.  Various expansions should not
	  be performed if parameter is in double quotes.
	- the getopts description says assigning OPTIND a value other than 1
	  produces undefined results, while the rationale for getopts suggests
	  saving/restoring the OPTIND value inside functions (since POSIX
	  functions don't do the save/restore automatically).  Restoring
	  OPTIND is kind of dumb since getopts may have been in the middle
	  of parsing a group of flags (eg, -abc).
	- unclear whether arithmetic expressions (eg, $((..))) should
	  understand C integer constants (ie, 0x123, 0177).  at&t ksh doesn't
	  and neither does pdksh.
	- `...` definition (3.6.3) says nothing about backslash followed by
	  a newline, which sh and at&t ksh strip out completely.  e.g.,
		$ show-args `echo 'X
		Y'`
		Number of args: 1
			1: <XY>
		$ 
	  POSIX would indicate the backslash-newline would be preserved.
